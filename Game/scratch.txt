	/* 
	 setup tests meshes
	*/
	Entity e = gCoordinator.CreateEntity();
	Mesh mesh_obj;
    // mesh_obj.tris = {
    //     // SOUTH face
    //     Triangle(Vertex(Vec3(0, 0, 0), Vec2(0, 1)), Vertex(Vec3(0, 1, 0), Vec2(0, 0)), Vertex(Vec3(1, 1, 0), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(0, 0, 0), Vec2(0, 1)), Vertex(Vec3(1, 1, 0), Vec2(1, 0)), Vertex(Vec3(1, 0, 0), Vec2(1, 1))),
    // 
    //     // EAST face
    //     Triangle(Vertex(Vec3(1, 0, 0), Vec2(0, 1)), Vertex(Vec3(1, 1, 0), Vec2(0, 0)), Vertex(Vec3(1, 1, 1), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(1, 0, 0), Vec2(0, 1)), Vertex(Vec3(1, 1, 1), Vec2(1, 0)), Vertex(Vec3(1, 0, 1), Vec2(1, 1))),
    // 
    //     // NORTH face
    //     Triangle(Vertex(Vec3(1, 0, 1), Vec2(0, 1)), Vertex(Vec3(1, 1, 1), Vec2(0, 0)), Vertex(Vec3(0, 1, 1), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(1, 0, 1), Vec2(0, 1)), Vertex(Vec3(0, 1, 1), Vec2(1, 0)), Vertex(Vec3(0, 0, 1), Vec2(1, 1))),
    // 
    //     // WEST face
    //     Triangle(Vertex(Vec3(0, 0, 1), Vec2(0, 1)), Vertex(Vec3(0, 1, 1), Vec2(0, 0)), Vertex(Vec3(0, 1, 0), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(0, 0, 1), Vec2(0, 1)), Vertex(Vec3(0, 1, 0), Vec2(1, 0)), Vertex(Vec3(0, 0, 0), Vec2(1, 1))),
    // 
    //     // TOP face
    //     Triangle(Vertex(Vec3(0, 1, 0), Vec2(0, 1)), Vertex(Vec3(0, 1, 1), Vec2(0, 0)), Vertex(Vec3(1, 1, 1), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(0, 1, 0), Vec2(0, 1)), Vertex(Vec3(1, 1, 1), Vec2(1, 0)), Vertex(Vec3(1, 1, 0), Vec2(1, 1))),
    // 
    //     // BOTTOM face
    //     Triangle(Vertex(Vec3(1, 0, 1), Vec2(0, 1)), Vertex(Vec3(0, 0, 1), Vec2(0, 0)), Vertex(Vec3(0, 0, 0), Vec2(1, 0))),
    //     Triangle(Vertex(Vec3(1, 0, 1), Vec2(0, 1)), Vertex(Vec3(0, 0, 0), Vec2(1, 0)), Vertex(Vec3(1, 0, 0), Vec2(1, 1))),
    // };
	Utils::LoadFromObjectFile("./Assets/furina.obj", mesh_obj, true, false);
	Transform transform = Transform(Vec3(0, 0, 15), Quat(Vec3(1, 0, 0), 3.141));
    SimpleTexture texture = SimpleTexture("./Assets/spot_texture.png");
	gCoordinator.AddComponent<Mesh>(e, mesh_obj);
	gCoordinator.AddComponent<Transform>(e, transform);
    gCoordinator.AddComponent<SimpleTexture>(e, texture);



    using std::chrono::high_resolution_clock;
	using std::chrono::duration_cast;
	using std::chrono::duration;
	using std::chrono::milliseconds;


    // test speed code
    /* Getting number of milliseconds as an integer. */
	// concurrent execution time
	auto t1 = high_resolution_clock::now();

    auto t2 = high_resolution_clock::now();
	
	duration<double, std::milli> ms_double_concurrent = t2 - t1;
	double concurrent = ms_double_concurrent.count();

	
	std::cout << "concurrent: " << concurrent << "ms\n";
	std::cout << "non concurrent: " << non_concurrent << "ms\n";


std::vector<Triangle> Renderer::ClipTriangle(Vec3& planePoint, Vec3& planeNormal, Triangle& clip)
{

    int insidePtCount = 0;
    int outsidePtCount = 0;
    
    Vertex* insideVtx[3];
    Vertex* outsideVtx[3];
    std::vector<Triangle> clippedTriangle;

    for (int i = 0; i < 3; i++) {
        float dist = Dist(clip.verts[i].pos, planeNormal, planePoint);
        if (dist >= 0) 
        {
            insideVtx[insidePtCount] = &clip.verts[i];
            insidePtCount++;
        }
        else 
        {
            outsideVtx[outsidePtCount] = &clip.verts[i];
            outsidePtCount++;
        }
    }
    

    if (insidePtCount == 0) 
    {
        // no triangle inside
        return clippedTriangle;
    }

    if (insidePtCount == 3) 
    {
        clippedTriangle.emplace_back(clip);
        return clippedTriangle;
    }

    if (insidePtCount == 1 && outsidePtCount == 2) 
    {
        Triangle newTri = clip;

        float t = 0;

        newTri.verts[0] = *insideVtx[0];
        newTri.verts[1].pos = IntersectPlane(planePoint, planeNormal, newTri.verts[0].pos, (*outsideVtx[0]).pos, t);
        newTri.verts[1].tex = (*insideVtx[0]).tex + ((*outsideVtx[0]).tex - (*insideVtx[0]).tex) * t;
        newTri.verts[1].invW = (*insideVtx[0]).invW + ((*outsideVtx[0]).invW - (*insideVtx[0]).invW) * t;
        newTri.verts[2].pos = IntersectPlane(planePoint, planeNormal, newTri.verts[0].pos, (*outsideVtx[1]).pos, t);
        newTri.verts[2].tex = (*insideVtx[0]).tex + ((*outsideVtx[1]).tex - (*insideVtx[0]).tex) * t;
        newTri.verts[2].invW = (*insideVtx[0]).invW + ((*outsideVtx[1]).invW - (*insideVtx[0]).invW) * t;

        clippedTriangle.emplace_back(newTri);

        return clippedTriangle;
    }

    if (insidePtCount == 2 && outsidePtCount == 1)
    {
        Triangle tri1 = clip, tri2 = clip;
        float t1 = 0, t2 = 0;

        tri1.verts[0] = *insideVtx[0];
        tri1.verts[1] = *insideVtx[1];
        tri1.verts[2].pos = IntersectPlane(planePoint, planeNormal, (*insideVtx[0]).pos, (*outsideVtx[0]).pos, t1);
        tri1.verts[2].tex = (*insideVtx[0]).tex + ((*outsideVtx[0]).tex - (*insideVtx[0]).tex) * t1;
        tri1.verts[2].invW = (*insideVtx[0]).invW + ((*outsideVtx[0]).invW - (*insideVtx[0]).invW) * t1;

        tri2.verts[0] = *insideVtx[1];
        tri2.verts[1] = tri1.verts[2];
        tri2.verts[2].pos = IntersectPlane(planePoint, planeNormal, (*insideVtx[1]).pos, (*outsideVtx[0]).pos, t2);
        tri2.verts[2].tex = (*insideVtx[1]).tex + ((*outsideVtx[0]).tex - (*insideVtx[1]).tex) * t2;
        tri2.verts[2].invW = (*insideVtx[1]).invW + ((*outsideVtx[0]).invW - (*insideVtx[1]).invW) * t2;

        clippedTriangle.emplace_back(tri1);
        clippedTriangle.emplace_back(tri2);
        return clippedTriangle;
    }

    assert(false, "unreachable code");
}


        // uint8_t outcodev1 = OutCode(v1);
        // uint8_t outcodev2 = OutCode(v2);
        // uint8_t outcodev3 = OutCode(v3);
        // 
        // uint8_t combineMask = outcodev1 | outcodev2 | outcodev3;
        // 
        // 
        // std::string s = "";
        // 
        // if (combineMask & RIGHT_PLANE) {
        //     s += "RIGHT: 1";
        // }
        // else {
        //     s += "RIGHT: 0";
        // }
        // 
        // s += ", "; // Separator between items
        // 
        // if (combineMask & LEFT_PLANE) {
        //     s += "LEFT: 1";
        // }
        // else {
        //     s += "LEFT: 0";
        // }
        // 
        // s += ", ";
        // 
        // if (combineMask & UP_PLANE) {
        //     s += "UP: 1";
        // }
        // else {
        //     s += "UP: 0";
        // }
        // 
        // s += ", ";
        // 
        // if (combineMask & DOWN_PLANE) {
        //     s += "DOWN: 1";
        // }
        // else {
        //     s += "DOWN: 0";
        // }
        // 
        // s += ", ";
        // 
        // if (combineMask & FAR_PLANE) {
        //     s += "FAR: 1";
        // }
        // else {
        //     s += "FAR: 0";
        // }
        // 
        // s += ", ";
        // 
        // if (combineMask & NEAR_PLANE) {
        //     s += "NEAR: 1";
        // }
        // else {
        //     s += "NEAR: 0";
        // }


         Vec4 v1 = cam.proj * Vec4(triangle.verts[0].pos);
        Vec4 v2 = cam.proj * Vec4(triangle.verts[1].pos);
        Vec4 v3 = cam.proj * Vec4(triangle.verts[2].pos);
        
        // Perspective division
        triangle.verts[0].pos = v1.ToVec3();
        triangle.verts[1].pos = v2.ToVec3();
        triangle.verts[2].pos = v3.ToVec3();
        
        triangle.verts[0].tex /= v1.w;
        triangle.verts[1].tex /= v2.w;
        triangle.verts[2].tex /= v3.w;
        
        
        triangle.verts[0].invW = 1.0f / v1.w;
        triangle.verts[1].invW = 1.0f / v2.w;
        triangle.verts[2].invW = 1.0f / v3.w;
        
        
        
        triangle.verts[0].pos.x = static_cast<int>((triangle.verts[0].pos.x + 1) * 0.5 * APP_VIRTUAL_WIDTH);
        triangle.verts[0].pos.y = static_cast<int>((triangle.verts[0].pos.y + 1) * 0.5 * APP_VIRTUAL_HEIGHT);
                                                 
        triangle.verts[1].pos.x = static_cast<int>((triangle.verts[1].pos.x + 1) * 0.5 * APP_VIRTUAL_WIDTH);
        triangle.verts[1].pos.y = static_cast<int>((triangle.verts[1].pos.y + 1) * 0.5 * APP_VIRTUAL_HEIGHT);
                   
        triangle.verts[2].pos.x = static_cast<int>((triangle.verts[2].pos.x + 1) * 0.5 * APP_VIRTUAL_WIDTH);
        triangle.verts[2].pos.y = static_cast<int>((triangle.verts[2].pos.y + 1) * 0.5 * APP_VIRTUAL_HEIGHT);
        
        // clip against 4 planes
        std::list<Triangle> clipped;
        clipped.push_back(triangle);
        int clipcount = 1;
        
        for (int sideID = 0; sideID < 4; sideID++) {
            while (clipcount > 0)
            {
                Triangle test = clipped.front();
                clipped.pop_front();
                clipcount--;
                std::vector<Triangle> boxClipped;
        
                switch (sideID) 
                {
                    case 0: boxClipped = ClipTriangle(Vec3(0.0f, 0.0f, 0.0f), Vec3(0.0f, 1.0f, 0.0f), test); break;
                    case 1: boxClipped = ClipTriangle(Vec3(0.0f, APP_VIRTUAL_HEIGHT - 1, 0.0f), Vec3(0.0f, -1.0f, 0.0f), test); break;
                    case 2: boxClipped = ClipTriangle(Vec3(0.0f, 0.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f), test); break;
                    case 3: boxClipped = ClipTriangle(Vec3(APP_VIRTUAL_WIDTH - 1, 0.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f), test); break;
                }
                clipped.insert(clipped.end(), boxClipped.begin(), boxClipped.end());
            }
            clipcount = clipped.size();
        }
        
        for (Triangle& clip : clipped) {
          
          RenderTriangle(clip, tex, depth);
        
          // DebugDraw(clip);
        
          //App::DrawTriangle(
          //    clip.verts[0].pos.x, clip.verts[0].pos.y,
          //    clip.verts[1].pos.x, clip.verts[1].pos.y,
          //    clip.verts[2].pos.x, clip.verts[2].pos.y,
          //    1, 1, 1
          //);
        }        
        // 
        // //App::Print(100, 150, s.c_str(), 1, 0, 0);


// Vec2 cornerA0 = t.GetCorner(tri.acceptIndex0);
// Vec2 cornerA1 = t.GetCorner(tri.acceptIndex1);
// Vec2 cornerA2 = t.GetCorner(tri.acceptIndex2);
// float eA0 = tri.EdgeFunc0(cornerA0);
// float eA1 = tri.EdgeFunc1(cornerA1);
// float eA2 = tri.EdgeFunc2(cornerA2);
// // trivial accept partial accept
// if (eA0 <= 0 && eA1 <= 0 && eA2 <= 0)
// {
//     t.DebugDraw(0, 1, 0);
// }
// else {
//     t.DebugDraw(0, 0, 1);
// } 


                            if (pixel.mask.GetBit(0)) {
                                m_color.SetColor(pixel.position.x[0], pixel.position.y[0], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(1)) {
                                m_color.SetColor(pixel.position.x[1], pixel.position.y[1], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(2)) {
                                m_color.SetColor(pixel.position.x[2], pixel.position.y[2], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(3)) {
                                m_color.SetColor(pixel.position.x[3], pixel.position.y[3], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(4)) {
                                m_color.SetColor(pixel.position.x[4], pixel.position.y[4], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(5)) {
                                m_color.SetColor(pixel.position.x[5], pixel.position.y[5], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(6)) {
                                m_color.SetColor(pixel.position.x[6], pixel.position.y[6], 255, 255, 255);
                            }
                        
                            if (pixel.mask.GetBit(7)) {
                                m_color.SetColor(pixel.position.x[7], pixel.position.y[7], 255, 255, 255);
                            }


                            #else
                for (int pixelY = minPt.y; pixelY < maxPt.y; pixelY++) {
                    for (int pixelX = minPt.x; pixelX < maxPt.x; pixelX++) {

                        Vec2 pixelE = Vec2(pixelX, pixelY);
                        float eA0 = tri.EdgeFunc0(pixelE);
                        float eA1 = tri.EdgeFunc1(pixelE);
                        float eA2 = tri.EdgeFunc2(pixelE);

                        constexpr float epsilon = -std::numeric_limits<float>::epsilon();

                        // trivial accept
                        if (eA0 <= 0 && eA1 <= 0 && eA2 <= 0 &&
                            (eA0 <= epsilon || eA1 <= epsilon || eA2 <= epsilon))
                        {
                            m_color.SetColor(pixelX, pixelY, 255, 255, 255);
                        }
                    }
                }
#endif


    float maxDepth = 0;
    
    for (int y = 0; y < APP_VIRTUAL_HEIGHT; y += SIMDPixel::pixelHeight) {
    
        for (int x = 0; x < APP_VIRTUAL_WIDTH; x += SIMDPixel::pixelWidth)
        {
            auto depth = m_depth.GetBuffer(x, y);
    
            if (depth[0] != 0.0) {
                if (depth[0] > maxDepth) {
                    maxDepth = depth[0];
                }
            }
            if (depth[1] != 0.0) {
                if (depth[1] > maxDepth) {
                    maxDepth = depth[1];
                }
            }
            if (depth[2] != 0.0) {
                if (depth[2] > maxDepth) {
                    maxDepth = depth[2];
                }
            }
            if (depth[3] != 0.0) {
                if (depth[3] > maxDepth) {
                    maxDepth = depth[3];
                }
            }
            if (depth[4] != 0.0) {
                if (depth[4] > maxDepth) {
                    maxDepth = depth[4];
                }
            }
            if (depth[5] != 0.0) {
                if (depth[5] > maxDepth) {
                    maxDepth = depth[5];
                }
            }
            if (depth[6] != 0.0) {
                if (depth[6] > maxDepth) {
                    maxDepth = depth[6];
                }
            }
            if (depth[7] != 0.0) {
                if (depth[7] > maxDepth) {
                    maxDepth = depth[7];
                }
            }
        }
    }
    
    for (int y = 0; y < APP_VIRTUAL_HEIGHT; y += SIMDPixel::pixelHeight) {
    
        for (int x = 0; x < APP_VIRTUAL_WIDTH ; x += SIMDPixel::pixelWidth)
        {
            auto depth = m_depth.GetBuffer(x, y);
    
            if (depth[0] != 0.0) {
                unsigned char color = depth[0] / maxDepth * 255;
                m_color.SetColor(x, y, color, color, color);
            }
            if (depth[1] != 0.0) {
                unsigned char color = depth[1] / maxDepth * 255;
                m_color.SetColor(x + 1, y, color, color, color);
            }
            if (depth[2] != 0.0) {
                unsigned char color = depth[2] / maxDepth * 255;
                m_color.SetColor(x + 2, y, color, color, color);
            }
            if (depth[3] != 0.0) {
                unsigned char color = depth[3] / maxDepth * 255;
                m_color.SetColor(x + 3, y, color, color, color);
            }
            if (depth[4] != 0.0) {
                unsigned char color = depth[4] / maxDepth * 255;
                m_color.SetColor(x, y + 1, color, color, color);
            }
            if (depth[5] != 0.0) {
                unsigned char color = depth[5] / maxDepth * 255;
                m_color.SetColor(x + 1, y + 1, color, color, color);
            }
            if (depth[6] != 0.0) {
                unsigned char color = depth[6] / maxDepth * 255;
                m_color.SetColor(x + 2, y + 1, color, color, color);
            }
            if (depth[7] != 0.0) {
                unsigned char color = depth[7] / maxDepth * 255;
                m_color.SetColor(x + 3, y + 1, color, color, color);
            }
        }
    }
                    // SimpleTexture& texture = m_textureList.textureList[tri.verts[0].tex_id];
                                // SIMDVec3 normal = (triSIMD.normal1 * alpha + triSIMD.normal1 * beta + triSIMD.normal3 * gamma) / depth;
                                // SIMDVec2 texUV = (triSIMD.tex1 * alpha + triSIMD.tex2 * beta + triSIMD.tex3 * gamma) / depth;
                                // 
                                // float r, g, b;
                                // 
                                // if (visible.GetBit(0))
                                // {
                                //     texture.Sample(texUV.x[0], texUV.y[0], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[0], pixel.position.y[0], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(1))
                                // {
                                //     texture.Sample(texUV.x[1], texUV.y[1], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[1], pixel.position.y[1], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(2))
                                // {
                                //     texture.Sample(texUV.x[2], texUV.y[2], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[2], pixel.position.y[2], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(3))
                                // {
                                //     texture.Sample(texUV.x[3], texUV.y[3], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[3], pixel.position.y[3], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(4))
                                // {
                                //     texture.Sample(texUV.x[4], texUV.y[4], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[4], pixel.position.y[4], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(5))
                                // {
                                //     texture.Sample(texUV.x[5], texUV.y[5], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[5], pixel.position.y[5], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(6))
                                // {
                                //     texture.Sample(texUV.x[6], texUV.y[6], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[6], pixel.position.y[6], r, g, b);
                                // }
                                // 
                                // if (visible.GetBit(7))
                                // {
                                //     texture.Sample(texUV.x[7], texUV.y[7], r, g, b);
                                //     m_color.SetColor(
                                //         pixel.position.x[7], pixel.position.y[7], r, g, b);
                                // }

                                            // 
            // g.AddMeshInstance(meshCopy);

            // Entity e = gCoordinator.CreateEntity();
            // auto mesh_obj = Mesh(meshCopy);
            // auto t2 = Transform(Vec3(x * 2, 0, 10), Quat(Vec3(1, 0, 0), 0.0)); // 3.14 / 2));
            // auto texture = SimpleTexture("./Assets/spot_texture.png",
            //                              Vec3(0, 0, 0),
            //                              Vec3(0, 0, 0),
            //                              Vec3(0, 0, 0), 0.0);
            // // 
            // gCoordinator.AddComponent<Mesh>(e, mesh_obj);
            // gCoordinator.AddComponent<Transform>(e, t2);
            // gCoordinator.AddComponent<SimpleTexture>(e, texture);


                    Triangle& triangle = m_ProjectedClip[pixel.binId][pixel.binIndex];
        pixel.Interpolate(triangle);
        Texture& texture = loader.GetTexture(triangle.verts[0].tex_id);

        SIMDVec2 texUV = pixel.textureCoord;

        float r, g, b;
        
        if (pixel.mask.GetBit(0))
        {
            texture.Sample(texUV.x[0], texUV.y[0], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[0], pixel.screenSpacePosition.y[0], r, g, b);
        }
        
        if (pixel.mask.GetBit(1))
        {
            texture.Sample(texUV.x[1], texUV.y[1], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[1], pixel.screenSpacePosition.y[1], r, g, b);
        }
        
        if (pixel.mask.GetBit(2))
        {
            texture.Sample(texUV.x[2], texUV.y[2], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[2], pixel.screenSpacePosition.y[2], r, g, b);
        }
        
        if (pixel.mask.GetBit(3))
        {
            texture.Sample(texUV.x[3], texUV.y[3], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[3], pixel.screenSpacePosition.y[3], r, g, b);
        }
        
        if (pixel.mask.GetBit(4))
        {
            texture.Sample(texUV.x[4], texUV.y[4], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[4], pixel.screenSpacePosition.y[4], r, g, b);
        }
        
        if (pixel.mask.GetBit(5))
        {
            texture.Sample(texUV.x[5], texUV.y[5], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[5], pixel.screenSpacePosition.y[5], r, g, b);
        }
        
        if (pixel.mask.GetBit(6))
        {
            texture.Sample(texUV.x[6], texUV.y[6], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[6], pixel.screenSpacePosition.y[6], r, g, b);
        }
        
        if (pixel.mask.GetBit(7))
        {
            texture.Sample(texUV.x[7], texUV.y[7], r, g, b);
            m_ColorBuffer.SetColor(pixel.screenSpacePosition.x[7], pixel.screenSpacePosition.y[7], r, g, b);
        }


            /**
     * /brief Get First Component Registered with an Entity useful for getting component we know to be singletons like Cameras
     */
    template <typename T>
    T& GetFirstComponent()
    {
        std::set<Entity> visitSet = Visit<T>();
        assert(visitSet.size() != 0 && "No Entity with component found!");
        return GetComponent<T>(*visitSet.begin());
    }

    #pragma once
#include <vector>
#include "MeshInstance.h"
#include "Mat4.h"
#include "Texture.h"
#include "DepthBuffer.h"
#include "Camera.h"
#include "ColorBuffer.h"
#include "Triangle.h"

/*
* /brief CPU ECSManager
*/

class RendererSimple
{
public:
    RendererSimple(Camera& cam, DepthBuffer& depth, ColorBuffer& color) : m_cam(cam), m_depth(depth), m_color(color)
    {
    }

    void RenderTriangle(Triangle& tri, Texture& tex);

    void DebugDraw(const Triangle& tri);

    void Render();

private:
    Camera& m_cam;
    DepthBuffer& m_depth;
    ColorBuffer& m_color;
};


#include "stdafx.h"
#include <algorithm>
#include "RendererSimple.h"
#include "Utils.h"
#include "ECSManager.h"
#include "Clipper.h"
#include "Vertex.h"
#include "../App/AppSettings.h"
#include "../app/app.h"


extern ECSManager ECS;

constexpr double ASPECT_RATIO = APP_VIRTUAL_WIDTH / APP_VIRTUAL_HEIGHT;


void ComputeBarycentricCoordinates(const Vertex& v1, const Vertex& v2, const Vertex& v3, float x, float y, float& alpha,
                                   float& beta, float& gamma)
{
    float det = (v2.pos.y - v3.pos.y) * (v1.pos.x - v3.pos.x) + (v3.pos.x - v2.pos.x) * (v1.pos.y - v3.pos.y);
    alpha = ((v2.pos.y - v3.pos.y) * (x - v3.pos.x) + (v3.pos.x - v2.pos.x) * (y - v3.pos.y)) / det;
    beta = ((v3.pos.y - v1.pos.y) * (x - v3.pos.x) + (v1.pos.x - v3.pos.x) * (y - v3.pos.y)) / det;
    gamma = 1.0f - alpha - beta;
}

void FillBottom(Vertex& v1, Vertex& v2, Vertex& v3, Texture& tex, DepthBuffer& depth, ColorBuffer& color)
{
    float delta = 1;
    float invslope1 = (v2.pos.x - v1.pos.x) / (v2.pos.y - v1.pos.y);
    float invslope2 = (v3.pos.x - v1.pos.x) / (v3.pos.y - v1.pos.y);
    invslope1 *= delta;
    invslope2 *= delta;


    float curx1 = v1.pos.x;
    float curx2 = v1.pos.x;

    if (invslope1 > invslope2)
    {
        std::swap(invslope1, invslope2);
    }

    for (float y = v1.pos.y; y <= v2.pos.y; y += delta)
    {
        for (float x = curx1; x < curx2; x += delta)
        {
            // ... interpolate u and v (texture coordinates) and draw point

            float alpha, beta, gamma;
            ComputeBarycentricCoordinates(v1, v2, v3, x, y, alpha, beta, gamma);
            float u = alpha * v1.uv.x + beta * v2.uv.x + gamma * v3.uv.x;
            float v = alpha * v1.uv.y + beta * v2.uv.y + gamma * v3.uv.y;
            float z = alpha * v1.invW + beta * v2.invW + gamma * v3.invW;
            Vec3 normal = v1.normal * alpha + v2.normal * beta + v3.normal * gamma;

            normal.x /= z;
            normal.y /= z;
            normal.z /= z;

            u /= z;
            v /= z;

            if (z > depth.GetBuffer(x, y))
            {
                float r = normal.x * 255, g = normal.y * 255, b = normal.z * 255;
                // tex.Sample(u, v, r, g, b);
                // App::DrawPoint(x, y, r / 255.0f, g / 255.0f, b / 255.0f);
                // color.SetColor(static_cast<int>(x), static_cast<int>(y), r, g, b);
                color.SetColor(static_cast<int>(x), static_cast<int>(y), r, g, b);
                depth.SetBuffer(static_cast<int>(x), static_cast<int>(y), z);
            }
        }
        curx1 += invslope1;
        curx2 += invslope2;
    }
}

void FillTop(Vertex& v1, Vertex& v2, Vertex& v3, Texture& tex, DepthBuffer& depth, ColorBuffer& color)
{
    float delta = 1;
    float invslope1 = (v3.pos.x - v1.pos.x) / (v3.pos.y - v1.pos.y);
    float invslope2 = (v3.pos.x - v2.pos.x) / (v3.pos.y - v2.pos.y);
    invslope1 *= delta;
    invslope2 *= delta;

    float curx1 = v3.pos.x;
    float curx2 = v3.pos.x;

    if (invslope1 < invslope2)
    {
        std::swap(invslope1, invslope2);
    }

    for (float y = v3.pos.y; y > v1.pos.y; y -= delta)
    {
        for (float x = curx1; x < curx2; x += delta)
        {
            // ... interpolate u and v (texture coordinates) and draw point
            float alpha, beta, gamma;
            ComputeBarycentricCoordinates(v1, v2, v3, x, y, alpha, beta, gamma);
            float u = alpha * v1.uv.x + beta * v2.uv.x + gamma * v3.uv.x;
            float v = alpha * v1.uv.y + beta * v2.uv.y + gamma * v3.uv.y;
            float z = alpha * v1.invW + beta * v2.invW + gamma * v3.invW;
            Vec3 normal =  v1.normal * alpha + v2.normal * beta + v3.normal * gamma;
            normal.x /= z;
            normal.y /= z;
            normal.z /= z;
            u /= z;
            v /= z;
            if (z > depth.GetBuffer(x, y))
            {
                float r = normal.x * 255, g = normal.y * 255, b = normal.z * 255;
                // tex.Sample(u, v, r, g, b);
                // App::DrawPoint(x, y, r / 255.0f, g / 255.0f, b / 255.0f);
                //color.SetColor(static_cast<int>(x), static_cast<int>(y), r, g, b);
                color.SetColor(static_cast<int>(x), static_cast<int>(y), r, g, b);
                depth.SetBuffer(static_cast<int>(x), static_cast<int>(y), z);
            }
        }
        curx1 -= invslope1;
        curx2 -= invslope2;
    }
}


void RendererSimple::RenderTriangle(Triangle& tri, Texture& tex)
{
    // Sort vertices by y-coordinate
    std::sort(std::begin(tri.verts), std::end(tri.verts), 
        [](const Vertex& a, const Vertex& b) {
        return a.pos.y < b.pos.y;
    });

    Vertex& v1 = tri.verts[0];
    Vertex& v2 = tri.verts[1];
    Vertex& v3 = tri.verts[2];

    // trivial reject
    if ((v1.pos.y == v2.pos.y && v2.pos.y == v3.pos.y) || v3.pos.y - v1.pos.y <= 1.0)
    {
        return;
    }

    if (v2.pos.y == v3.pos.y)
    {
        FillBottom(v1, v2, v3, tex, m_depth, m_color);
    }
    else if (v1.pos.y == v2.pos.y)
    {
        FillTop(v1, v2, v3, tex, m_depth, m_color);
    }
    else
    {
        // Interpolate to find the fourth vertex
        float t = (v2.pos.y - v3.pos.y) / (v1.pos.y - v3.pos.y);
        Vec3 pos4 = Vec3(v3.pos.x + (v1.pos.x - v3.pos.x) * t, v2.pos.y, 0);
        Vec2 tex4 = v3.uv + (v1.uv - v3.uv) * t;
        float w = v3.invW + (v1.invW - v3.invW) * t;
        Vertex v4(pos4, tex4);
        v4.invW = w;

        FillBottom(v1, v2, v3, tex, m_depth, m_color);
        FillTop(v2, v4, v3, tex, m_depth, m_color);
    }
}

void RendererSimple::DebugDraw(const Triangle& tri)
{
    Vec4 v1 = tri.verts[0].proj;
    Vec4 v2 = tri.verts[1].proj;
    Vec4 v3 = tri.verts[2].proj;

    App::DrawLine(v1.x, v1.y, v2.x, v2.y, 1, 0, 0);
    App::DrawLine(v1.x, v1.y, v3.x, v3.y, 1, 0, 0);
    App::DrawLine(v2.x, v2.y, v3.x, v3.y, 1, 0, 0);
}

void RendererSimple::Render()
{
    // m_depth.ClearBuffer();
    // m_color.Clear();
    // 
    // std::vector<Triangle> TrianglesToRaster;
    // Texture tex;
    // 
    // // Geometric pipeline
    // for (Entity const& e : Visit<Mesh, Transform, Texture>(ECSManager))
    // {
    //     Mesh& mesh = ECSManager.GetComponent<Mesh>(e);
    //     tex = ECSManager.GetComponent<Texture>(e);
    // 
    //     for (Triangle& tri : mesh.tris)
    //     {
    //         // transform triangle by model matrix
    //         Triangle translation = tri;
    // 
    //         Vec3 normal = (translation.verts[0].normal + translation.verts[1].normal + translation.verts[2].normal) * (
    //             1.0f / 3.0f);
    //         // back face culling
    //         if (normal.Dot(translation.verts[0].pos - m_cam.pos) > 0)
    //         {
    //             // transform triangle into camera space
    //             Triangle view = translation;
    //             view.verts[0].pos = m_cam.WorldToCamera(view.verts[0].pos);
    //             view.verts[1].pos = m_cam.WorldToCamera(view.verts[1].pos);
    //             view.verts[2].pos = m_cam.WorldToCamera(view.verts[2].pos);
    //             view.verts[0].proj = m_cam.proj * Vec4(view.verts[0].pos);
    //             view.verts[1].proj = m_cam.proj * Vec4(view.verts[1].pos);
    //             view.verts[2].proj = m_cam.proj * Vec4(view.verts[2].pos);
    //             // clip against the near plane
    //             TrianglesToRaster.push_back(view);
    //         }
    //     }
    // }
    // 
    // for (Triangle& triangle : TrianglesToRaster)
    // {
    //     std::vector<Triangle> clipped = ClipAgainstPlane(triangle);
    // 
    //     for (Triangle& clip : clipped)
    //     {
    //         m_cam.ToRasterSpace(clip.verts[0].proj);
    //         m_cam.ToRasterSpace(clip.verts[1].proj);
    //         m_cam.ToRasterSpace(clip.verts[2].proj);
    // 
    //         clip.verts[0].pos.x = clip.verts[0].proj.x;
    //         clip.verts[0].pos.y = clip.verts[0].proj.y;
    //         clip.verts[1].pos.x = clip.verts[1].proj.x;
    //         clip.verts[1].pos.y = clip.verts[1].proj.y;
    //         clip.verts[2].pos.x = clip.verts[2].proj.x;
    //         clip.verts[2].pos.y = clip.verts[2].proj.y;
    // 
    //         RenderTriangle(clip, tex);
    //     }
    // }
    // 
    // 
    // App::RenderTexture(m_color.GetBuffer());
}
    for (auto e : ECS.Visit<Transform, CircleCollider>())
    {
        // Transform
        auto& t = ECS.GetComponent<Transform>(e);
        auto& c = ECS.GetComponent<CircleCollider>(e);
        Vec3 newpos = t.TransformVec3(Vec3(c.posOrg.x, c.posOrg.y, 0.0));

        c.collides = false;
        c.pos.x = newpos.x;
        c.pos.y = newpos.y;
    }

    for (auto e : ECS.Visit<Transform, AABB>())
    {
        // Transform
        auto& t = ECS.GetComponent<Transform>(e);
        auto& aabb = ECS.GetComponent<AABB>(e);
        Vec3 newmax = t.TransformVec3(Vec3(aabb.maxOrg.x, aabb.maxOrg.y, 0.0));
        aabb.max.x = newmax.x;
        aabb.max.y = newmax.y;
        Vec3 newmin = t.TransformVec3(Vec3(aabb.minOrg.x, aabb.minOrg.y, 0.0));

        aabb.collides = false;
        aabb.min.x = newmin.x;
        aabb.min.y = newmin.y;
    }

    std::vector<Manifold> collisions;

    // Detect Collisions Narrow Phase
    for (auto bodyA : ECS.Visit<RigidBody>())
    {
        for (auto bodyB : ECS.Visit<RigidBody>())
        {
            if (bodyA == bodyB || bodyB > bodyA) continue;


            Manifold collides;

            if (ECS.HasComponent<CircleCollider>(bodyA) && 
                ECS.HasComponent<CircleCollider>(bodyB))
            {
                collides = Manifold(bodyA, bodyB);
                CircleCollider& A = ECS.GetComponent<CircleCollider>(bodyA);
                CircleCollider& B = ECS.GetComponent<CircleCollider>(bodyB);

                if (CircleCollides(collides, A, B))
                {
                    // Generate Manifolds
                    collisions.push_back(collides);
                    A.collides = true;
                    B.collides = true;
                }
            }
            else if (ECS.HasComponent<AABB>(bodyA) &&
                     ECS.HasComponent<AABB>(bodyB))
            {
                collides = Manifold(bodyA, bodyB);

                AABB& A = ECS.GetComponent<AABB>(bodyA);
                AABB& B = ECS.GetComponent<AABB>(bodyB);

                if (AABBCollides(collides, A, B))
                {
                    collisions.push_back(collides);
                    A.collides = true;
                    B.collides = true;
                }
            }
            else if (ECS.HasComponent<AABB>(bodyA) &&
                ECS.HasComponent<CircleCollider>(bodyB))
            {
                collides = Manifold(bodyA, bodyB);

                AABB& A = ECS.GetComponent<AABB>(bodyA);
                CircleCollider& B = ECS.GetComponent<CircleCollider>(bodyB);
                if (AABBCircleCollides(collides, A, B))
                {
                    collisions.push_back(collides);
                    A.collides = true;
                    B.collides = true;
                }

            }
            else if (ECS.HasComponent<CircleCollider>(bodyA) &&
                     ECS.HasComponent<AABB>(bodyB))
            {
                collides = Manifold(bodyB, bodyA);

                AABB& B = ECS.GetComponent<AABB>(bodyB);
                CircleCollider& A = ECS.GetComponent<CircleCollider>(bodyA);
                if (AABBCircleCollides(collides, B, A))
                {
                    collisions.push_back(collides);
                    A.collides = true;
                    B.collides = true;
                }
            }
        }
    }

    for (auto& manifold : collisions)
    {
        // resolve collision
        auto& t1 = ECS.GetComponent<Transform>(manifold.A);
        auto& t2 = ECS.GetComponent<Transform>(manifold.B);
        auto& r1 = ECS.GetComponent<RigidBody>(manifold.A);
        auto& r2 = ECS.GetComponent<RigidBody>(manifold.B);

        const float percent = 1.0f;

        Vec2 correction = manifold.normal * (manifold.penetration / (r1.invMass + r2.invMass) * percent);

        Vec3 correction1 = Vec3(r1.invMass * correction.x, r2.invMass * correction.y, 0.0);

        Vec3 correction2 = Vec3(r2.invMass * correction.x, r2.invMass * correction.y, 0.0);

        t1.Update(correction1, Quat());
        t2.Update(correction2 * -1, Quat());
    }


    // inline bool AABBvAABB(AABB& a, AABB& b)
// {
//     if (a.max.x < b.min.x || a.min.x > b.max.x) return false;
//     if (a.max.y < b.min.y || a.min.y > b.max.y) return false;
//     // No separating axis found, therefor there is at least one overlapping axis
//     return true;
// }
// 
// inline bool CirclevCircle(CircleCollider& a, CircleCollider& b)
// {
//     float r = a.radius + b.radius;
//     r *= r;
//     return std::pow(a.pos.x - b.pos.x, 2.0f) + std::pow(a.pos.y - b.pos.y, 2.0f) <= r;
// }
// 
// 
// inline float SquaredDistance(Vec2 p, AABB box) {
//     float sqDist = 0.0;
// 
//     // For each axis count any excess distance outside box extents
//     if (p.x < box.min.x) sqDist += (box.min.x - p.x) * (box.min.x - p.x);
//     if (p.x > box.max.x) sqDist += (p.x - box.max.x) * (p.x - box.max.x);
//     if (p.y < box.min.y) sqDist += (box.min.y - p.y) * (box.min.y - p.y);
//     if (p.y > box.max.y) sqDist += (p.y - box.max.y) * (p.y - box.max.y);
// 
//     return sqDist;
// }
// 
// inline bool AABBvCircle(AABB& box, CircleCollider& circle)
// {
//     float sqDist = SquaredDistance(circle.pos, box);
//     return sqDist <= circle.radius * circle.radius;
// }
// 
// 
// bool CircleCollides(Manifold& m, CircleCollider& c1, CircleCollider& c2)
// {
//     if (!CirclevCircle(c1, c2))
//         return false;
// 
//     Vec2 n = c1.pos - c2.pos;
//     float r = c1.radius + c2.radius;
// 
//     float distance = n.GetMagnitude();
// 
//     if (distance != 0)
//     {
//         m.penetration = r - distance;
//         m.normal = n / distance; 
//     }
//     else
//     {
//         m.penetration = c1.radius;
//         m.normal = Vec2(1, 0);
//     }
// 
//     return true;
// }
// 
// bool AABBCollides(Manifold& m, AABB& a1, AABB& a2)
// {
//     if (!AABBvAABB(a1, a2))
//         return false;
// 
//     return true;
// }
// 
// bool AABBCircleCollides(Manifold& m, AABB& aabb, CircleCollider& circle)
// {
//     if (!AABBvCircle(aabb, circle))
//         return false;
// 
//     
//     return true;
// }


inline float SquaredDistance(Vec2 boxPos, Vec2 circlePos, Shape& box) {
    float sqDist = 0.0;
    Vec2 boxMax = boxPos + box.max;
    Vec2 boxMin = boxPos + box.min;

    // For each axis count any excess distance outside box extents
    if (circlePos.x < boxMin.x) sqDist += (boxMin.x - circlePos.x) * (boxMin.x - circlePos.x);
    if (circlePos.x > boxMax.x) sqDist += (circlePos.x - boxMax.x) * (circlePos.x - boxMax.x);
    if (circlePos.y < boxMin.y) sqDist += (boxMin.y - circlePos.y) * (boxMin.y - circlePos.y);
    if (circlePos.y > boxMax.y) sqDist += (circlePos.y - boxMax.y) * (circlePos.y - boxMax.y);

    return sqDist;
}

inline bool AABB2CircleCollision(Vec2& boxPos, Vec2& circlePos, Shape& box, Shape& circle)
{
    float sqDist = SquaredDistance(boxPos, circlePos, box);
    return sqDist <= circle.radius * circle.radius;
}


//
    Vec2 edgeA1, edgeA2;
    Vec2 edgeB1, edgeB2;

    ClosestEdge(m.normal * -1.0f, polyA, edgeA1, edgeA2);
    ClosestEdge(m.normal, polyB, edgeB1, edgeB2);

    AShape.debugPoints.clear();
    AShape.debugPoints.push_back(edgeA1);
    AShape.debugPoints.push_back(edgeA2);

    BShape.debugPoints.clear();
    BShape.debugPoints.push_back(edgeB1);
    BShape.debugPoints.push_back(edgeB2);

    Vec2 e1 = edgeA2 - edgeA1;
    Vec2 e2 = edgeB2 - edgeB1;

    Vec2 refv;
    Vec2 refv1;
    Vec2 refv2;
    Vec2 incv1;
    Vec2 incv2;

    bool flip = false;

    if (std::abs(e1.Dot(normal)) <= std::abs(e2.Dot(normal)))
    {
        refv = e1;
        refv1 = edgeA1;
        refv2 = edgeA2;
        incv1 = edgeB1;
        incv2 = edgeB2;
    }
    else
    {
        refv = e2;
        refv1 = edgeB1;
        refv2 = edgeB2;
        incv1 = edgeA1;
        incv2 = edgeA2;
        flip = true;
    }

    refv.Normalize();

    float o1 = refv.Dot(refv1);
    std::vector<Vec2> cp1 = ClipPoints(incv1, incv2, refv, o1);
    assert(cp1.size() == 2);
    float o2 = refv.Dot(refv2);
    std::vector<Vec2> cp2 = ClipPoints(cp1[0], cp1[1], -refv, -o2);
    assert(cp2.size() == 2);



    for (auto& edge : edgeNormals)
    {
        float edgeMinA, edgeMaxA;
        float edgeMinB, edgeMaxB;
    
        ProjectShape(polyA, edge, edgeMinA, edgeMaxA);
        ProjectShape(polyB, edge, edgeMinB, edgeMaxB);
    
        // ranges do not overlap imply they do not collide
        if (edgeMaxA < edgeMinB || edgeMaxB < edgeMinA)
        {
            m.collided = false;
            break; // Exit as soon as a separating axis is found
        }
    
        float overlapStart = (std::max)(edgeMinA, edgeMinB);
        float overlapEnd = (std::min)(edgeMaxA, edgeMaxB);
        float test_overlap = overlapEnd - overlapStart;
    
        if ((edgeMinA <= edgeMinB && edgeMaxB <= edgeMaxB) ||
            (edgeMinB <= edgeMinA && edgeMaxA <= edgeMaxB))
        {
            float mins = std::abs(edgeMinA - edgeMinB);
            float maxs = std::abs(edgeMaxA - edgeMaxB);
            if (mins < maxs) {
                test_overlap += mins;
            }
            else {
                test_overlap += maxs;
            }
        }
    
    
        if (test_overlap < penetration)
        {
            penetration = test_overlap;
            normal = edge;
    
        }
    }


        for (int x = 0; x < 1; x++)
    {
        Entity meshEntity = ECS.CreateEntity();
        auto modelTransform = Transform(Vec3(0.0f, 0.0, 5.0), Quat(Vec3(0, 0, 1), 0.0));
        auto meshRB = RigidBody(1.0f);
        meshRB.Controlled = true;
        //ECS.AddComponent<Mesh>(meshEntity, Mesh(Pacman));
        ECS.AddComponent<Transform>(meshEntity, modelTransform);
        ECS.AddComponent<RigidBody>(meshEntity, meshRB);
    }

        //for (int x = 0; x < APP_VIRTUAL_WIDTH; x++)
    //{
    //    for (int y = 0; y < APP_VIRTUAL_HEIGHT; y++)
    //    {
    //        unsigned char r, g, b;
    //        m_ColorBuffer->GetColor(x, y, r, g, b);
    //        App::DrawPoint(
    //            static_cast<float>(x), 
    //            static_cast<float>(y), 
    //            r / 225.0, g / 255.0, b / 255.0 
    //        );
    //    }
    //}


    void CreateRigidBodyRect(float x, float y, float width, float height, float rotation)
{
    float radians = (3.141f  / 180.0f) * rotation;

    Entity entity = ECS.CreateEntity();
    auto transform = Transform(Vec3(x, y, 5.0f), Quat(Vec3(0.0f, 0.0f, 1.0f), radians));
    ECS.AddComponent<Transform>(entity, transform);
    auto rigidbody = RigidBody(width, height);
    rigidbody.SetStatic(true);
    ECS.AddComponent<RigidBody>(entity, rigidbody);
}

void CreateRigidBodyCircle(float x, float y, float radius)
{
    Entity entity = ECS.CreateEntity();
    auto transform = Transform(Vec3(x, y, 5.0f), Quat(Vec3(0.0f, 0.0f, 1.0f), 0.0));
    ECS.AddComponent<Transform>(entity, transform);
    auto rigidbody = RigidBody(radius);
    rigidbody.SetStatic(true);
    ECS.AddComponent<RigidBody>(entity, rigidbody);
} 