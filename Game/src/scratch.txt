

for (Entity e : Visitor<RigidBody, Transform> v(coordinator)) {
	auto r = coordinator.GetComponent<RigidBody>(e);

}


/*
* /brief CPU based Renderer
*/
class RendererCPU {
public:
	RendererCPU() {};
	void Init();
	void Render();
private:
	std::vector<Mesh> meshes;
	Mat4 proj;
	void PainterSort(std::vector<Triangle>& mesh);
};

void RendererCPU::Init()
{
	Mesh mesh_obj;
    Utils::LoadFromObjectFile("./Assets/teapot.obj", mesh_obj);
    Transform transform = Transform(Vec3(0, 3, 8), Quat(Vec3(1, 0, 0), 3.141f));;
    mesh_obj.transform = transform;
    meshes.push_back(mesh_obj);
    proj.PerspectiveOpenGL(90.0f, ASPECT_RATIO, 0.1, 1000);
}

void RendererCPU::Render()
{

    std::vector<Triangle> TrianglesToRaster;

    for (Mesh& mesh : meshes) {

        Transform* t = &mesh.transform;

        for (Triangle& tri : mesh.tris) {
            //t->rotation *= Quat(Vec3(0, 1, 0), 0.001f * 3.141f / 180.0f);
            //t->rotation *= Quat(Vec3(1, 0, 0), 0.001f * 3.141f / 180.0f);
            Triangle translation = tri.transform(*t);
            
            Vec3 lineA = translation.tri[1] - translation.tri[0];
            Vec3 lineB = translation.tri[2] - translation.tri[0];
            Vec3 camera = Vec3(0, 0, 0);
            Vec3 normal = lineA.Cross(lineB);
            normal.Normalize();

            translation.normal = normal;
            
            if (normal.Dot(translation.tri[0] - camera) < 0) 
            {
                TrianglesToRaster.push_back(translation);
            }
        }
    }

    PainterSort(TrianglesToRaster);

    for (Triangle& tri : TrianglesToRaster) {

        Vec3 light_direction = Vec3(0, 0, -1.0f);

        float dp = tri.normal.Dot(light_direction);

        Triangle translation = tri;
        Triangle projected;
        projected.tri[0] = (proj * Vec4(translation.tri[0])).ToVec3();
        projected.tri[1] = (proj * Vec4(translation.tri[1])).ToVec3();
        projected.tri[2] = (proj * Vec4(translation.tri[2])).ToVec3();

        projected.tri[0].x = (projected.tri[0].x + 1) * 0.5 * APP_VIRTUAL_WIDTH;
        projected.tri[0].y = (projected.tri[0].y + 1) * 0.5 * APP_VIRTUAL_HEIGHT;


        projected.tri[1].x = (projected.tri[1].x + 1) * 0.5 * APP_VIRTUAL_WIDTH;
        projected.tri[1].y = (projected.tri[1].y + 1) * 0.5 * APP_VIRTUAL_HEIGHT;

        projected.tri[2].x = (projected.tri[2].x + 1) * 0.5 * APP_VIRTUAL_WIDTH;
        projected.tri[2].y = (projected.tri[2].y + 1) * 0.5 * APP_VIRTUAL_HEIGHT;


        //App::DrawLine(
        //    projected.tri[0].x, projected.tri[0].y,
        //    projected.tri[1].x, projected.tri[1].y,
        //    1, 0, 0
        //);
        //
        //App::DrawLine(
        //    projected.tri[0].x, projected.tri[0].y,
        //    projected.tri[2].x, projected.tri[2].y,
        //    1, 0, 0
        //);
        //
        //
        //App::DrawLine(
        //    projected.tri[1].x, projected.tri[1].y,
        //    projected.tri[2].x, projected.tri[2].y,
        //    1, 0, 0
        //);

        App::DrawTriangle(
            projected.tri[0].x, projected.tri[0].y,
            projected.tri[1].x, projected.tri[1].y,
            projected.tri[2].x, projected.tri[2].y,
            dp, dp, dp
        );
    }
}

void RendererCPU::PainterSort(std::vector<Triangle>& sort)
{
    std::sort(sort.begin(), sort.end(), 
    [](Triangle& t1, Triangle& t2) {
        float z1 = (t1.tri[0].z + t1.tri[1].z + t1.tri[2].z) / 3;
        float z2 = (t2.tri[0].z + t2.tri[1].z + t2.tri[2].z) / 3;
        return z1 > z2;
    });
}


